{
  "approach": "We use a sliding window with two hash maps (one for `t`'s count, one for the current window). We expand the window until we have all characters from `t`, then we shrink it from the left to find the minimum size while still satisfying the condition.",
  "solutionCode": {
    "javascript": "/**\n * @param {string} s\n * @param {string} t\n * @return {string}\n */\nvar minWindow = function(s, t) {\n    if (t.length === 0) return \"\";\n    const countT = new Map();\n    for (const c of t) countT.set(c, (countT.get(c) || 0) + 1);\n    \n    let have = 0, need = countT.size;\n    const window = new Map();\n    let res = [-1, -1], resLen = Infinity;\n    let l = 0;\n    \n    for (let r = 0; r < s.length; r++) {\n        const c = s[r];\n        window.set(c, (window.get(c) || 0) + 1);\n        if (countT.has(c) && window.get(c) === countT.get(c)) have++;\n        \n        while (have === need) {\n            if ((r - l + 1) < resLen) {\n                res = [l, r];\n                resLen = r - l + 1;\n            }\n            window.set(s[l], window.get(s[l]) - 1);\n            if (countT.has(s[l]) && window.get(s[l]) < countT.get(s[l])) have--;\n            l++;\n        }\n    }\n    return resLen !== Infinity ? s.slice(res[0], res[1] + 1) : \"\";\n};",
    "python": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if t == \"\": return \"\"\n        countT, window = {}, {}\n        for c in t:\n            countT[c] = 1 + countT.get(c, 0)\n        \n        have, need = 0, len(countT)\n        res, resLen = [-1, -1], float(\"inf\")\n        l = 0\n        \n        for r in range(len(s)): \n            c = s[r]\n            window[c] = 1 + window.get(c, 0)\n            if c in countT and window[c] == countT[c]:\n                have += 1\n            while have == need:\n                if (r - l + 1) < resLen:\n                    res = [l, r]\n                    resLen = r - l + 1\n                window[s[l]] -= 1\n                if s[l] in countT and window[s[l]] < countT[s[l]]:\n                    have -= 1\n                l += 1\n        l, r = res\n        return s[l : r + 1] if resLen != float(\"inf\") else \"\"",
    "cpp": "class Solution {\npublic:\n    string minWindow(string s, string t) {\n        if (t == \"\") return \"\";\n        unordered_map<char, int> countT, window;\n        for (char c : t) countT[c]++;\n        \n        int have = 0, need = countT.size();\n        int res[2] = {-1, -1}, resLen = INT_MAX;\n        int l = 0;\n        \n        for (int r = 0; r < s.length(); r++) {\n            char c = s[r];\n            window[c]++;\n            if (countT.count(c) && window[c] == countT[c]) have++;\n            \n            while (have == need) {\n                if ((r - l + 1) < resLen) {\n                    res[0] = l;\n                    res[1] = r;\n                    resLen = r - l + 1;\n                }\n                window[s[l]]--;\n                if (countT.count(s[l]) && window[s[l]] < countT[s[l]]) have--;\n                l++;\n            }\n        }\n        return resLen != INT_MAX ? s.substr(res[0], resLen) : \"\";\n    }\n};"
  }
}