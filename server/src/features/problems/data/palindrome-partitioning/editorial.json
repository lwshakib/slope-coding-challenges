{
  "approach": "Backtracking. For each starting position, verify if the prefix is a palindrome. If yes, add it to the current partition and recurse for the rest of the string.",
  "solutionCode": {
    "javascript": "/**\n * @param {string} s\n * @return {string[][]}\n */\nvar partition = function(s) {\n    const res = [];\n    const part = [];\n    \n    function dfs(i) {\n        if (i >= s.length) {\n            res.push([...part]);\n            return;\n        }\n        for (let j = i; j < s.length; j++) {\n            if (isPali(s, i, j)) {\n                part.push(s.slice(i, j + 1));\n                dfs(j + 1);\n                part.pop();\n            }\n        }\n    }\n    \n    function isPali(s, l, r) {\n        while (l < r) {\n            if (s[l] !== s[r]) return false;\n            l++;\n            r--;\n        }\n        return true;\n    }\n    \n    dfs(0);\n    return res;\n};",
    "python": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res, part = [], []\n        def dfs(i):\n            if i >= len(s):\n                res.append(part.copy())\n                return\n            for j in range(i, len(s)):\n                if self.isPali(s, i, j):\n                    part.append(s[i:j+1])\n                    dfs(j+1)\n                    part.pop()\n        dfs(0)\n        return res\n                    \n    def isPali(self, s, l, r):\n        while l < r:\n            if s[l] != s[r]:\n                return False\n            l, r = l + 1, r - 1\n        return True",
    "cpp": "class Solution {\npublic:\n    vector<vector<string>> partition(string s) {\n        vector<vector<string>> res;\n        vector<string> part;\n        dfs(0, s, part, res);\n        return res;\n    }\n    void dfs(int i, string& s, vector<string>& part, vector<vector<string>>& res) {\n        if (i >= s.length()) {\n            res.push_back(part);\n            return;\n        }\n        for (int j = i; j < s.length(); j++) {\n            if (isPali(s, i, j)) {\n                part.push_back(s.substr(i, j - i + 1));\n                dfs(j + 1, s, part, res);\n                part.pop_back();\n            }\n        }\n    }\n    bool isPali(string& s, int l, int r) {\n        while (l < r) {\n            if (s[l] != s[r]) return false;\n            l++; r--;\n        }\n        return true;\n    }\n};"
  }
}