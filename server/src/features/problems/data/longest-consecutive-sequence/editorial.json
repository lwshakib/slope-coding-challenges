{
  "approach": "We can put all numbers into a Hash Set for O(1) lookups. Then, we iterate through the set. If a number `n` is the start of a sequence (i.e., `n-1` is not in the set), we check for `n+1`, `n+2`, etc., to find the length of the sequence start at `n`.",
  "solutionCode": {
    "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar longestConsecutive = function(nums) {\n    if (nums.length === 0) return 0;\n    const numSet = new Set(nums);\n    let longest = 0;\n    for (const num of numSet) {\n        if (!numSet.has(num - 1)) {\n            let currentNum = num;\n            let currentStreak = 1;\n            while (numSet.has(currentNum + 1)) {\n                currentNum += 1;\n                currentStreak += 1;\n            }\n            longest = Math.max(longest, currentStreak);\n        }\n    }\n    return longest;\n};",
    "python": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        numSet = set(nums)\n        longest = 0\n        for n in numSet:\n            if (n - 1) not in numSet:\n                length = 0\n                while (n + length) in numSet:\n                    length += 1\n                longest = max(length, longest)\n        return longest",
    "cpp": "class Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        unordered_set<int> numSet(nums.begin(), nums.end());\n        int longest = 0;\n        for (int n : numSet) {\n            if (numSet.find(n - 1) == numSet.end()) {\n                int length = 0;\n                while (numSet.find(n + length) != numSet.end()) {\n                    length++;\n                }\n                longest = max(longest, length);\n            }\n        }\n        return longest;\n    }\n};"
  }
}