{
  "approach": "This is a Topological Sort problem. We can use DFS to detect cycles. If there is a cycle, we can't finish all courses. We maintain a set of visited nodes in the current path. If we visit a node already in the current path, a cycle exists.",
  "solutionCode": {
    "javascript": "/**\n * @param {number} numCourses\n * @param {number[][]} prerequisites\n * @return {boolean}\n */\nvar canFinish = function(numCourses, prerequisites) {\n    const preMap = new Map();\n    for (let i = 0; i < numCourses; i++) preMap.set(i, []);\n    for (const [crs, pre] of prerequisites) {\n        preMap.get(crs).push(pre);\n    }\n    \n    const visit = new Set();\n    function dfs(crs) {\n        if (visit.has(crs)) return false;\n        if (preMap.get(crs).length === 0) return true;\n        \n        visit.add(crs);\n        for (const pre of preMap.get(crs)) {\n            if (!dfs(pre)) return false;\n        }\n        visit.delete(crs);\n        preMap.set(crs, []);\n        return true;\n    }\n    \n    for (let c = 0; c < numCourses; c++) {\n        if (!dfs(c)) return false;\n    }\n    return true;\n};",
    "python": "class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        preMap = {i: [] for i in range(numCourses)}\n        for crs, pre in prerequisites:\n            preMap[crs].append(pre)\n        visit = set()\n        def dfs(crs):\n            if crs in visit:\n                return False\n            if preMap[crs] == []:\n                return True\n            visit.add(crs)\n            for pre in preMap[crs]:\n                if not dfs(pre):\n                    return False\n            visit.remove(crs)\n            preMap[crs] = []\n            return True\n        for crs in range(numCourses):\n            if not dfs(crs):\n                return False\n        return True",
    "cpp": "class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> adj(numCourses);\n        for (auto& p : prerequisites) adj[p[0]].push_back(p[1]);\n        \n        vector<int> visited(numCourses, 0); // 0: unvisited, 1: visiting, 2: visited\n        for (int i = 0; i < numCourses; i++) {\n            if (hasCycle(i, adj, visited)) return false;\n        }\n        return true;\n    }\n    bool hasCycle(int curr, vector<vector<int>>& adj, vector<int>& visited) {\n        if (visited[curr] == 1) return true;\n        if (visited[curr] == 2) return false;\n        visited[curr] = 1;\n        for (int next : adj[curr]) {\n            if (hasCycle(next, adj, visited)) return true;\n        }\n        visited[curr] = 2;\n        return false;\n    }\n};"
  }
}