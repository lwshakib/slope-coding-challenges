{
  "approach": "We use BFS. Add all initially rotten oranges to the queue. Process level by level (minute by minute). For each rotten orange, rot adjacent fresh oranges and add them to the queue. Keep track of fresh orange count. If count is 0 at end, return time, else -1.",
  "solutionCode": {
    "javascript": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar orangesRotting = function(grid) {\n    let fresh = 0;\n    const q = [];\n    const rows = grid.length, cols = grid[0].length;\n    for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n            if (grid[r][c] === 2) q.push([r, c]);\n            else if (grid[r][c] === 1) fresh++;\n        }\n    }\n    \n    if (fresh === 0) return 0;\n    let time = 0;\n    const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    \n    while (q.length && fresh > 0) {\n        const len = q.length;\n        for (let i = 0; i < len; i++) {\n            const [r, c] = q.shift();\n            for (const [dr, dc] of dirs) {\n                const nr = r + dr, nc = c + dc;\n                if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] === 1) {\n                    grid[nr][nc] = 2;\n                    q.push([nr, nc]);\n                    fresh--;\n                }\n            }\n        }\n        time++;\n    }\n    return fresh === 0 ? time : -1;\n};",
    "python": "class Solution:\n    def orangesRotting(self, grid: List[List[int]]) -> int:\n        q = collections.deque()\n        fresh, time = 0, 0\n        rows, cols = len(grid), len(grid[0])\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] == 1:\n                    fresh += 1\n                if grid[r][c] == 2:\n                    q.append((r, c))\n                    \n        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n        while q and fresh > 0:\n            for i in range(len(q)):\n                r, c = q.popleft()\n                for dr, dc in directions:\n                    row, col = r + dr, c + dc\n                    if (row < 0 or row == rows or\n                        col < 0 or col == cols or\n                        grid[row][col] != 1):\n                        continue\n                    grid[row][col] = 2\n                    q.append((row, col))\n                    fresh -= 1\n            time += 1\n        return time if fresh == 0 else -1",
    "cpp": "class Solution {\npublic:\n    int orangesRotting(vector<vector<int>>& grid) {\n        int fresh = 0, time = 0;\n        queue<pair<int, int>> q;\n        int rows = grid.size(), cols = grid[0].size();\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                if (grid[r][c] == 2) q.push({r, c});\n                else if (grid[r][c] == 1) fresh++;\n            }\n        }\n        if (fresh == 0) return 0;\n        vector<pair<int, int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        while (!q.empty() && fresh > 0) {\n            int len = q.size();\n            for (int i = 0; i < len; i++) {\n                pair<int, int> p = q.front(); q.pop();\n                for (auto d : dirs) {\n                    int nr = p.first + d.first;\n                    int nc = p.second + d.second;\n                    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] == 1) {\n                        grid[nr][nc] = 2;\n                        q.push({nr, nc});\n                        fresh--;\n                    }\n                }\n            }\n            time++;\n        }\n        return fresh == 0 ? time : -1;\n    }\n};"
  }
}