{
  "approach": "Since the houses are in a circle, we can't rob both the first and last house. So the problem reduces to two cases: rob houses 0 to n-2 or rob houses 1 to n-1. Solve both using House Robber I logic and take the max.",
  "solutionCode": {
    "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar rob = function(nums) {\n    if (nums.length === 0) return 0;\n    if (nums.length === 1) return nums[0];\n    \n    function helper(arr) {\n        let rob1 = 0, rob2 = 0;\n        for (const n of arr) {\n            const temp = Math.max(n + rob1, rob2);\n            rob1 = rob2;\n            rob2 = temp;\n        }\n        return rob2;\n    }\n    return Math.max(helper(nums.slice(0, nums.length - 1)), helper(nums.slice(1)));\n};",
    "python": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        return max(nums[0], self.helper(nums[1:]), self.helper(nums[:-1]))\n\n    def helper(self, nums):\n        rob1, rob2 = 0, 0\n        for n in nums:\n            newRob = max(rob1 + n, rob2)\n            rob1 = rob2\n            rob2 = newRob\n        return rob2",
    "cpp": "class Solution {\npublic:\n    int rob(vector<int>& nums) {\n        if (nums.empty()) return 0;\n        if (nums.size() == 1) return nums[0];\n        return max(helper(nums, 0, nums.size() - 2), helper(nums, 1, nums.size() - 1));\n    }\n    int helper(vector<int>& nums, int start, int end) {\n        int rob1 = 0, rob2 = 0;\n        for (int i = start; i <= end; i++) {\n            int temp = max(nums[i] + rob1, rob2);\n            rob1 = rob2;\n            rob2 = temp;\n        }\n        return rob2;\n    }\n};"
  }
}