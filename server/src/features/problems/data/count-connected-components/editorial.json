{
  "approach": "We can use Union Find. Initialize `n` components. For each edge, union the two nodes. If they are already connected, do nothing. If not, decrement component count.",
  "solutionCode": {
    "javascript": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number}\n */\nvar countComponents = function(n, edges) {\n    const parent = Array.from({length: n}, (_, i) => i);\n    let count = n;\n    function find(x) {\n        if (parent[x] !== x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    function union(x, y) {\n        const rootX = find(x), rootY = find(y);\n        if (rootX !== rootY) {\n            parent[rootX] = rootY;\n            count--;\n        }\n    }\n    for (const [u, v] of edges) union(u, v);\n    return count;\n};",
    "python": "class Solution:\n    def countComponents(self, n: int, edges: List[List[int]]) -> int:\n        par = [i for i in range(n)]\n        rank = [1] * n\n        def find(n1):\n            res = n1\n            while res != par[res]:\n                par[res] = par[par[res]]\n                res = par[res]\n            return res\n        def union(n1, n2):\n            p1, p2 = find(n1), find(n2)\n            if p1 == p2:\n                return 0\n            if rank[p1] > rank[p2]:\n                par[p2] = p1\n                rank[p1] += rank[p2]\n            else:\n                par[p1] = p2\n                rank[p2] += rank[p1]\n            return 1\n        res = n\n        for n1, n2 in edges:\n            res -= union(n1, n2)\n        return res",
    "cpp": "class Solution {\npublic:\n    int countComponents(int n, vector<vector<int>>& edges) {\n        vector<int> parent(n);\n        iota(parent.begin(), parent.end(), 0);\n        int count = n;\n        for (auto& e : edges) {\n            if (unite(e[0], e[1], parent)) count--;\n        }\n        return count;\n    }\n    int find(int i, vector<int>& parent) {\n        if (parent[i] == i) return i;\n        return parent[i] = find(parent[i], parent);\n    }\n    bool unite(int i, int j, vector<int>& parent) {\n        int rootI = find(i, parent);\n        int rootJ = find(j, parent);\n        if (rootI != rootJ) {\n            parent[rootI] = rootJ;\n            return true;\n        }\n        return false;\n    }\n};"
  }
}