{
  "approach": "We separate start times and end times, sort both. Iterate through start times. If a start time is less than strict minimum end time, we need a room. If start >= end, we freed a room (move end pointer).",
  "solutionCode": {
    "javascript": "/**\n * @param {number[][]} intervals\n * @return {number}\n */\nvar minMeetingRooms = function(intervals) {\n    const start = intervals.map(i => i[0]).sort((a, b) => a - b);\n    const end = intervals.map(i => i[1]).sort((a, b) => a - b);\n    \n    let res = 0, count = 0;\n    let s = 0, e = 0;\n    while (s < intervals.length) {\n        if (start[s] < end[e]) {\n            s++;\n            count++;\n        } else {\n            e++;\n            count--;\n        }\n        res = Math.max(res, count);\n    }\n    return res;\n};",
    "python": "class Solution:\n    def minMeetingRooms(self, intervals: List[List[int]]) -> int:\n        start = sorted([i[0] for i in intervals])\n        end = sorted([i[1] for i in intervals])\n        res, count = 0, 0\n        s, e = 0, 0\n        while s < len(intervals):\n            if start[s] < end[e]:\n                s += 1\n                count += 1\n            else:\n                e += 1\n                count -= 1\n            res = max(res, count)\n        return res",
    "cpp": "class Solution {\npublic:\n    int minMeetingRooms(vector<vector<int>>& intervals) {\n        vector<int> start, end;\n        for (auto& i : intervals) {\n            start.push_back(i[0]);\n            end.push_back(i[1]);\n        }\n        sort(start.begin(), start.end());\n        sort(end.begin(), end.end());\n        int res = 0, count = 0, s = 0, e = 0;\n        while (s < intervals.size()) {\n            if (start[s] < end[e]) {\n                s++;\n                count++;\n            } else {\n                e++;\n                count--;\n            }\n            res = max(res, count);\n        }\n        return res;\n    }\n};"
  }
}