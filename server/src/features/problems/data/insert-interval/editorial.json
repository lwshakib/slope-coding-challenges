{
  "approach": "Iterate through intervals. Add all intervals ending before newInterval starts. Merge all overlapping intervals with newInterval (min start, max end). Add remaining intervals.",
  "solutionCode": {
    "javascript": "/**\n * @param {number[][]} intervals\n * @param {number[]} newInterval\n * @return {number[][]}\n */\nvar insert = function(intervals, newInterval) {\n    const res = [];\n    let i = 0;\n    while (i < intervals.length && intervals[i][1] < newInterval[0]) {\n        res.push(intervals[i]);\n        i++;\n    }\n    while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n        newInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])];\n        i++;\n    }\n    res.push(newInterval);\n    while (i < intervals.length) {\n        res.push(intervals[i]);\n        i++;\n    }\n    return res;\n};",
    "python": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        res = []\n        for i in range(len(intervals)):\n            if newInterval[1] < intervals[i][0]:\n                res.append(newInterval)\n                return res + intervals[i:]\n            elif newInterval[0] > intervals[i][1]:\n                res.append(intervals[i])\n            else:\n                newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]\n        res.append(newInterval)\n        return res",
    "cpp": "class Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>> res;\n        for (int i = 0; i < intervals.size(); i++) {\n            if (newInterval[1] < intervals[i][0]) {\n                res.push_back(newInterval);\n                for (; i < intervals.size(); i++) res.push_back(intervals[i]);\n                return res;\n            } else if (newInterval[0] > intervals[i][1]) {\n                res.push_back(intervals[i]);\n            } else {\n                newInterval[0] = min(newInterval[0], intervals[i][0]);\n                newInterval[1] = max(newInterval[1], intervals[i][1]);\n            }\n        }\n        res.push_back(newInterval);\n        return res;\n    }\n};"
  }
}