{
  "approach": "We can use In-order Traversal (Iterative or Recursive). In a BST, in-order traversal visits nodes in ascending order. We just need to stop at the kth visited node.",
  "solutionCode": {
    "javascript": "/**\n * @param {TreeNode} root\n * @param {number} k\n * @return {number}\n */\nvar kthSmallest = function(root, k) {\n    const stack = [];\n    let curr = root;\n    let count = 0;\n    while (curr || stack.length) {\n        while (curr) {\n            stack.push(curr);\n            curr = curr.left;\n        }\n        curr = stack.pop();\n        count++;\n        if (count === k) return curr.val;\n        curr = curr.right;\n    }\n};",
    "python": "class Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        stack = []\n        curr = root\n        n = 0\n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            n += 1\n            if n == k:\n                return curr.val\n            curr = curr.right",
    "cpp": "class Solution {\npublic:\n    int kthSmallest(TreeNode* root, int k) {\n        stack<TreeNode*> stack;\n        TreeNode* curr = root;\n        int n = 0;\n        while (curr || !stack.empty()) {\n            while (curr) {\n                stack.push(curr);\n                curr = curr->left;\n            }\n            curr = stack.top();\n            stack.pop();\n            n++;\n            if (n == k) return curr->val;\n            curr = curr->right;\n        }\n        return -1;\n    }\n};"
  }
}