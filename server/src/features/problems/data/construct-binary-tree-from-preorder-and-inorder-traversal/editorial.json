{
  "approach": "The first element of preorder is the root. Find this element in the inorder array. Everything to the left of it in inorder is the left subtree, and everything to the right is the right subtree. Recursively build the tree.",
  "solutionCode": {
    "javascript": "/**\n * @param {number[]} preorder\n * @param {number[]} inorder\n * @return {TreeNode}\n */\nvar buildTree = function(preorder, inorder) {\n    if (!preorder.length || !inorder.length) return null;\n    \n    const rootVal = preorder[0];\n    const root = new TreeNode(rootVal);\n    const mid = inorder.indexOf(rootVal);\n    \n    root.left = buildTree(preorder.slice(1, mid + 1), inorder.slice(0, mid));\n    root.right = buildTree(preorder.slice(mid + 1), inorder.slice(mid + 1));\n    \n    return root;\n};",
    "python": "class Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        if not preorder or not inorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        \n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        \n        return root",
    "cpp": "class Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        if (preorder.empty() || inorder.empty()) return nullptr;\n        \n        TreeNode* root = new TreeNode(preorder[0]);\n        int mid = distance(inorder.begin(), find(inorder.begin(), inorder.end(), preorder[0]));\n        \n        vector<int> leftPreorder(preorder.begin() + 1, preorder.begin() + mid + 1);\n        vector<int> leftInorder(inorder.begin(), inorder.begin() + mid);\n        vector<int> rightPreorder(preorder.begin() + mid + 1, preorder.end());\n        vector<int> rightInorder(inorder.begin() + mid + 1, inorder.end());\n        \n        root->left = buildTree(leftPreorder, leftInorder);\n        root->right = buildTree(rightPreorder, rightInorder);\n        \n        return root;\n    }\n};"
  }
}