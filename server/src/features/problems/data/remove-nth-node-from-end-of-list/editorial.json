{
  "approach": "We use a dummy node pointing to the head. We maintain two pointers `left` and `right`. Move `right` `n + 1` steps forward. Then move both `left` and `right` until `right` reaches the end. `left` will be at the node before the one to remove.",
  "solutionCode": {
    "javascript": "/**\n * @param {ListNode} head\n * @param {number} n\n * @return {ListNode}\n */\nvar removeNthFromEnd = function(head, n) {\n    const dummy = new ListNode(0, head);\n    let left = dummy;\n    let right = head;\n    while (n > 0 && right) {\n        right = right.next;\n        n--;\n    }\n    \n    while (right) {\n        left = left.next;\n        right = right.next;\n    }\n    \n    left.next = left.next.next;\n    return dummy.next;\n};",
    "python": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        dummy = ListNode(0, head)\n        left = dummy\n        right = head\n        while n > 0 and right:\n            right = right.next\n            n -= 1\n        while right:\n            left = left.next\n            right = right.next\n        left.next = left.next.next\n        return dummy.next",
    "cpp": "class Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* dummy = new ListNode(0, head);\n        ListNode* left = dummy;\n        ListNode* right = head;\n        while (n > 0 && right) {\n            right = right->next;\n            n--;\n        }\n        while (right) {\n            left = left->next;\n            right = right->next;\n        }\n        left->next = left->next->next;\n        return dummy->next;\n    }\n};"
  }
}