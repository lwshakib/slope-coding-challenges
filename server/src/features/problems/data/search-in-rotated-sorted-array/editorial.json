{
  "approach": "We can use Binary Search. The key is that at least one half of the rotated array is always sorted. We find which half is sorted, check if the target is in that range, and adjust our pointers accordingly.",
  "solutionCode": {
    "javascript": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function(nums, target) {\n    let l = 0, r = nums.length - 1;\n    while (l <= r) {\n        const m = Math.floor((l + r) / 2);\n        if (nums[m] === target) return m;\n        \n        if (nums[l] <= nums[m]) {\n            if (target > nums[m] || target < nums[l]) l = m + 1;\n            else r = m - 1;\n        } else {\n            if (target < nums[m] || target > nums[r]) r = m - 1;\n            else l = m + 1;\n        }\n    }\n    return -1;\n};",
    "python": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[l] <= nums[mid]:\n                if target > nums[mid] or target < nums[l]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n            else:\n                if target < nums[mid] or target > nums[r]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n        return -1",
    "cpp": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int l = 0, r = nums.size() - 1;\n        while (l <= r) {\n            int mid = (l + r) / 2;\n            if (nums[mid] == target) return mid;\n            if (nums[l] <= nums[mid]) {\n                if (target > nums[mid] || target < nums[l]) l = mid + 1;\n                else r = mid - 1;\n            } else {\n                if (target < nums[mid] || target > nums[r]) r = mid - 1;\n                else l = mid + 1;\n            }\n        }\n        return -1;\n    }\n};"
  }
}