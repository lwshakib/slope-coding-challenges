{
  "approach": "We use DFS/BFS starting from the ocean edges. We reverse the flow logic: instead of flowing down, we flow up from the ocean to land. Cells reachable from Pacific are stored in one set, Atlantic in another. The result is the intersection.",
  "solutionCode": {
    "javascript": "/**\n * @param {number[][]} heights\n * @return {number[][]}\n */\nvar pacificAtlantic = function(heights) {\n    const rows = heights.length, cols = heights[0].length;\n    const pac = new Set(), atl = new Set();\n    \n    function dfs(r, c, visit, prevHeight) {\n        if (r < 0 || c < 0 || r >= rows || c >= cols || visit.has(`${r},${c}`) || heights[r][c] < prevHeight) return;\n        visit.add(`${r},${c}`);\n        dfs(r + 1, c, visit, heights[r][c]);\n        dfs(r - 1, c, visit, heights[r][c]);\n        dfs(r, c + 1, visit, heights[r][c]);\n        dfs(r, c - 1, visit, heights[r][c]);\n    }\n    \n    for (let c = 0; c < cols; c++) {\n        dfs(0, c, pac, heights[0][c]);\n        dfs(rows - 1, c, atl, heights[rows - 1][c]);\n    }\n    for (let r = 0; r < rows; r++) {\n        dfs(r, 0, pac, heights[r][0]);\n        dfs(r, cols - 1, atl, heights[r][cols - 1]);\n    }\n    \n    const res = [];\n    for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n            if (pac.has(`${r},${c}`) && atl.has(`${r},${c}`)) res.push([r, c]);\n        }\n    }\n    return res;\n};",
    "python": "class Solution:\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n        rows, cols = len(heights), len(heights[0])\n        pac, atl = set(), set()\n        \n        def dfs(r, c, visit, prevHeight):\n            if ((r, c) in visit or r < 0 or c < 0 or r == rows or c == cols or heights[r][c] < prevHeight):\n                return\n            visit.add((r, c))\n            dfs(r + 1, c, visit, heights[r][c])\n            dfs(r - 1, c, visit, heights[r][c])\n            dfs(r, c + 1, visit, heights[r][c])\n            dfs(r, c - 1, visit, heights[r][c])\n            \n        for c in range(cols):\n            dfs(0, c, pac, heights[0][c])\n            dfs(rows - 1, c, atl, heights[rows - 1][c])\n            \n        for r in range(rows):\n            dfs(r, 0, pac, heights[r][0])\n            dfs(r, cols - 1, atl, heights[r][cols - 1])\n            \n        res = []\n        for r in range(rows):\n            for c in range(cols):\n                if (r, c) in pac and (r, c) in atl:\n                    res.append([r, c])\n        return res",
    "cpp": "class Solution {\npublic:\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\n        int rows = heights.size();\n        int cols = heights[0].size();\n        set<pair<int, int>> pac;\n        set<pair<int, int>> atl;\n        \n        for (int c = 0; c < cols; c++) {\n            dfs(0, c, pac, heights[0][c], heights);\n            dfs(rows - 1, c, atl, heights[rows - 1][c], heights);\n        }\n        for (int r = 0; r < rows; r++) {\n            dfs(r, 0, pac, heights[r][0], heights);\n            dfs(r, cols - 1, atl, heights[r][cols - 1], heights);\n        }\n        \n        vector<vector<int>> res;\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                if (pac.count({r, c}) && atl.count({r, c})) res.push_back({r, c});\n            }\n        }\n        return res;\n    }\n    void dfs(int r, int c, set<pair<int,int>>& visit, int prevHeight, vector<vector<int>>& heights) {\n        if (r < 0 || c < 0 || r >= heights.size() || c >= heights[0].size() || visit.count({r, c}) || heights[r][c] < prevHeight) return;\n        visit.insert({r, c});\n        dfs(r + 1, c, visit, heights[r][c], heights);\n        dfs(r - 1, c, visit, heights[r][c], heights);\n        dfs(r, c + 1, visit, heights[r][c], heights);\n        dfs(r, c - 1, visit, heights[r][c], heights);\n    }\n};"
  }
}