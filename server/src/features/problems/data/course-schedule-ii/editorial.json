{
  "approach": "Also Topological Sort. We can use DFS again. When a node is fully processed (all prerequisites met), add it to the result list.",
  "solutionCode": {
    "javascript": "/**\n * @param {number} numCourses\n * @param {number[][]} prerequisites\n * @return {number[]}\n */\nvar findOrder = function(numCourses, prerequisites) {\n    const preMap = new Map();\n    for (let c = 0; c < numCourses; c++) preMap.set(c, []);\n    for (const [crs, pre] of prerequisites) {\n        preMap.get(crs).push(pre);\n    }\n    \n    const visit = new Set(), cycle = new Set();\n    const output = [];\n    \n    function dfs(crs) {\n        if (cycle.has(crs)) return false;\n        if (visit.has(crs)) return true;\n        \n        cycle.add(crs);\n        for (const pre of preMap.get(crs)) {\n            if (!dfs(pre)) return false;\n        }\n        cycle.delete(crs);\n        visit.add(crs);\n        output.push(crs);\n        return true;\n    }\n    \n    for (let c = 0; c < numCourses; c++) {\n        if (!dfs(c)) return [];\n    }\n    return output;\n};",
    "python": "class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        prereq = {c: [] for c in range(numCourses)}\n        for crs, pre in prerequisites:\n            prereq[crs].append(pre)\n        output = []\n        visit, cycle = set(), set()\n        def dfs(crs):\n            if crs in cycle:\n                return False\n            if crs in visit:\n                return True\n            cycle.add(crs)\n            for pre in prereq[crs]:\n                if not dfs(pre):\n                    return False\n            cycle.remove(crs)\n            visit.add(crs)\n            output.append(crs)\n            return True\n        for c in range(numCourses):\n            if not dfs(c):\n                return []\n        return output",
    "cpp": "class Solution {\npublic:\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> adj(numCourses);\n        for (auto& p : prerequisites) adj[p[0]].push_back(p[1]);\n        vector<int> state(numCourses, 0); // 0: unvisited, 1: visiting, 2: visited\n        vector<int> result;\n        for (int i = 0; i < numCourses; i++) {\n            if (hasCycle(i, adj, state, result)) return {};\n        }\n        return result;\n    }\n    bool hasCycle(int u, vector<vector<int>>& adj, vector<int>& state, vector<int>& result) {\n        if (state[u] == 1) return true;\n        if (state[u] == 2) return false;\n        state[u] = 1;\n        for (int v : adj[u]) {\n            if (hasCycle(v, adj, state, result)) return true;\n        }\n        state[u] = 2;\n        result.push_back(u);\n        return false;\n    }\n};"
  }
}