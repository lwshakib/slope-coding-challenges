{
  "approach": "Iterate through each cell. If '1', start DFS/BFS to calculate area and mark visited. Update max area.",
  "solutionCode": {
    "javascript": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar maxAreaOfIsland = function(grid) {\n    let maxArea = 0;\n    const rows = grid.length;\n    const cols = grid[0].length;\n    function dfs(r, c) {\n        if (r < 0 || c < 0 || r >= rows || c >= cols || grid[r][c] === 0) return 0;\n        grid[r][c] = 0;\n        return 1 + dfs(r + 1, c) + dfs(r - 1, c) + dfs(r, c + 1) + dfs(r, c - 1);\n    }\n    for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n            if (grid[r][c] === 1) {\n                maxArea = Math.max(maxArea, dfs(r, c));\n            }\n        }\n    }\n    return maxArea;\n};",
    "python": "class Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        rows, cols = len(grid), len(grid[0])\n        max_area = 0\n        def dfs(r, c):\n            if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == 0:\n                return 0\n            grid[r][c] = 0\n            return 1 + dfs(r+1, c) + dfs(r-1, c) + dfs(r, c+1) + dfs(r, c-1)\n            \n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] == 1:\n                    max_area = max(max_area, dfs(r, c))\n        return max_area",
    "cpp": "class Solution {\npublic:\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        int maxArea = 0;\n        int rows = grid.size();\n        int cols = grid[0].size();\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                if (grid[r][c] == 1) {\n                    maxArea = max(maxArea, dfs(grid, r, c));\n                }\n            }\n        }\n        return maxArea;\n    }\n    int dfs(vector<vector<int>>& grid, int r, int c) {\n        if (r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size() || grid[r][c] == 0) return 0;\n        grid[r][c] = 0;\n        return 1 + dfs(grid, r + 1, c) + dfs(grid, r - 1, c) + dfs(grid, r, c + 1) + dfs(grid, r, c - 1);\n    }\n};"
  }
}