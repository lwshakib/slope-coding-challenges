{
  "approach": "For each string, we can use the character count (a tuple of 26 integers) as a key in a hash map. Strings with the same character count are anagrams and will be grouped together.",
  "solutionCode": {
    "javascript": "/**\n * @param {string[]} strs\n * @return {string[][]}\n */\nvar groupAnagrams = function(strs) {\n    const map = new Map();\n    for (const s of strs) {\n        const count = new Array(26).fill(0);\n        for (const c of s) {\n            count[c.charCodeAt(0) - 97]++;\n        }\n        const key = count.join('#');\n        if (!map.has(key)) map.set(key, []);\n        map.get(key).push(s);\n    }\n    return Array.from(map.values());\n};",
    "python": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        ans = collections.defaultdict(list)\n        for s in strs:\n            count = [0] * 26\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n            ans[tuple(count)].append(s)\n        return ans.values()",
    "cpp": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string, vector<string>> map;\n        for (string s : strs) {\n            string key = s;\n            sort(key.begin(), key.end());\n            map[key].push_back(s);\n        }\n        vector<vector<string>> result;\n        for (auto p : map) {\n            result.push_back(p.second);\n        }\n        return result;\n    }\n};"
  }
}