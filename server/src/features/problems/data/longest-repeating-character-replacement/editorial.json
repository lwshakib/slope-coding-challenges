{
  "approach": "We use a sliding window approach. We maintain a count of characters in the window and keep track of the count of the most frequent character. If the window size minus the most frequent character count is greater than k, we need to shrink the window.",
  "solutionCode": {
    "javascript": "/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar characterReplacement = function(s, k) {\n    const count = new Map();\n    let res = 0;\n    let l = 0, maxf = 0;\n    for (let r = 0; r < s.length; r++) {\n        count.set(s[r], (count.get(s[r]) || 0) + 1);\n        maxf = Math.max(maxf, count.get(s[r]));\n        if ((r - l + 1) - maxf > k) {\n            count.set(s[l], count.get(s[l]) - 1);\n            l++;\n        }\n        res = Math.max(res, r - l + 1);\n    }\n    return res;\n};",
    "python": "class Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        count = {}\n        l = 0\n        maxf = 0\n        res = 0\n        for r in range(len(s)):\n            count[s[r]] = 1 + count.get(s[r], 0)\n            maxf = max(maxf, count[s[r]])\n            if (r - l + 1) - maxf > k:\n                count[s[l]] -= 1\n                l += 1\n            res = max(res, r - l + 1)\n        return res",
    "cpp": "class Solution {\npublic:\n    int characterReplacement(string s, int k) {\n        vector<int> count(26, 0);\n        int l = 0, maxf = 0, res = 0;\n        for (int r = 0; r < s.length(); r++) {\n            count[s[r] - 'A']++;\n            maxf = max(maxf, count[s[r] - 'A']);\n            if ((r - l + 1) - maxf > k) {\n                count[s[l] - 'A']--;\n                l++;\n            }\n            res = max(res, r - l + 1);\n        }\n        return res;\n    }\n};"
  }
}